#pragma config(Sensor, in1,    G_SENSOR,       sensorGyro)
#pragma config(Sensor, in2,    PWR,            sensorPotentiometer)
#pragma config(Sensor, in3,    ACC_X,          sensorAccelerometer)
#pragma config(Sensor, in4,    ACC_Y,          sensorAccelerometer)
#pragma config(Sensor, in5,    ACC_Z,          sensorAccelerometer)
#pragma config(Sensor, in6,    DUMP_ANGLE,     sensorPotentiometer)
#pragma config(Sensor, in7,    LIFT_POT,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  WHEEL_R,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  WHEEL_L,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  P_TRANS,        sensorDigitalOut)
#pragma config(Sensor, dgtl10, P_CLAW_R,       sensorDigitalOut)
#pragma config(Sensor, dgtl11, P_CLAW_L,       sensorDigitalOut)
#pragma config(Sensor, dgtl12, P_LIFT,         sensorDigitalOut)
#pragma config(Motor,  port1,           M_DRV_FL,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           M_DUMP_R3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           M_DRV_BL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           M_DUMP_L1,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           M_DUMP_L2,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           M_DUMP_R2,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           M_DUMP_R1,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           M_DRV_BR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           M_DUMP_L3,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          M_DRV_FR,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")

#pragma platform(VEX)
#pragma competitionControl(Competition)
//#pragma competitionControl(OFF)
#pragma autonomousDuration(20)
#pragma userControlDuration(1200)
#include "Vex_Competition_Includes.c"

// include functions from Libs (the always reusable code)
#include "Libs\FuncLib.c"     // basic functions
#include "Libs\Pid.c"         // pid functions
// -- Motorlib (slew rate control, timeout, bailout)
#define MOTOR_USE_SLEW          1     //
int MOTOR_SLEW[10] =  { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };  // has to match motor numbers
#define MOTOR_SLEW_DELAY        20     //

//void bailout(); //Defined first, body filled later
#include "Libs/MotorCtrl.c"
// -- Push-release buttons
const int NUM_PR_BUTTONS = 8;    // define how many buttons to monitor as PR buttons
#define PR_Btn7U 0
// #define PR_Btn7R 1
#define PR_Btn7D 1
#define PR_Btn7L 2
#define PR_Btn8L 3
#define PR_Btn8U 4
#define PR_Btn8R 5
#define PR_Btn8D 6
#define PR_Btn5U 7
#include "Libs\PR_Button.c"     // include source file

// include ss specific files -- order matters
#include "ss.h"                 // head file
#include "ss_func.c"            // very basic functions -- is_bailout, is_timeout, battery ,...
#include "ss_lcd.c"             // lcd functions
#include "ss_monitor.c"         // sensor monitoring functions and task -- all sensor value codes be here
#include "ss_dump.c"            // dump functions and task
#include "ss_move.c"            // movement functions and task
#include "ss_lift.c"            // lift functions and task
#include "ss_auton.c"           // auton, skills, and complex movements


// use different slew for driving and skills/auton
void set_slew(int opt) {
  if (opt==0) {
    for ( unsigned  int i=0;i<10;i++) {
      MOTOR_SLEW[i] = 15;
    }
  }
  else if (opt==1) {
    // no slew for dumper
    MOTOR_SLEW[1] = 255;
    MOTOR_SLEW[8] = 255;
    MOTOR_SLEW[3] = 255;
    MOTOR_SLEW[4] = 255;
    MOTOR_SLEW[5] = 255;
    MOTOR_SLEW[6] = 255;
    // make wheels twice as faster
    MOTOR_SLEW[0] = 30;
    MOTOR_SLEW[2] = 30;
    MOTOR_SLEW[7] = 30;
    MOTOR_SLEW[9] = 30;
  }
}

/*
PRE AUTONOMOUS
functions
*/

void sensor_reset() {
	SensorValue(ACC_X) = 0;
	SensorValue(ACC_Y) = 0;
	SensorValue(ACC_Z) = 0;
	SensorValue(G_SENSOR) = 0;
	SensorValue(WHEEL_L) = 0;
	SensorValue(WHEEL_R) = 0;
  wait1Msec(2000);    // necessary for gyro calibration
}

void global_variable_reset() {

}

void pre_auton(){
  bStopTasksBetweenModes = false; //Keep tasks between Auton and user control

	// show battery voltage
	#if DEBUG == YES
	  writeDebugStreamLine("pre_auton");
	  writeDebugStreamLine("%%  batt %4.2fv %4.2fv", volt1() / 1000.0, volt2()/1000.0);
	#endif

  //Initialize Button library
  // add_pr_button(PR_Btn7R,1,Btn7R);
  add_pr_button(PR_Btn7U,1,Btn7U);
  add_pr_button(PR_Btn7D,1,Btn7D);
  add_pr_button(PR_Btn8L,1,Btn8L);
  add_pr_button(PR_Btn8U,1,Btn8U);
  add_pr_button(PR_Btn8R,1,Btn8R);
  add_pr_button(PR_Btn8D,1,Btn8D);
  add_pr_button(PR_Btn5U,1,Btn5U);
  start_pr_button();

  clearTimer(T1);
  sensor_reset();
  global_variable_reset();
  wheel_init();

  claw(CLOSE);

  //LCD
  lcd_selection();
  lcd_msg_init();

  //Start Tasks
  startTask(MotorSlewRateTask, 9);
  startTask(ss_monitor, 9);
  startTask(ss_dump, 9);
  startTask(ss_lift, 9);
}

/*
 	AUTONOMOUS
	task
]*/

task autonomous(){
  #if DEBUG == YES
  	writeDebugStreamLine("autonomous");
	#endif

  //Make sure user control is turned off
  stopTask(usercontrol);
  // make slew rate faster
  set_slew(1);

	clearTimer(T1);
	if (MODE == AUTO_A) auto_A();
	if (MODE == AUTO_B) auto_B();
	if (MODE == AUTO_C) auto_C();
	// if (MODE == AUTO_D) auto_D();
	if (MODE == PRG_SKILL) {
    set_slew(0);
    prg_skills();
  }
	lcd_message();
}

/*
	USER CONTROL
*/

task usercontrol(){

	//Make sure auton is off
  stopTask( autonomous );

	#if DEBUG == YES
	  writeDebugStreamLine("usercontrol");
	#endif

  // use default slew protection
  set_slew(0);


	int V, H;

	//DUMP_MONITOR = START; //Update dumper values
  // if we are doing drving skills, we will first run
  // prg_mv1 and prg_mv2 (only breakable by 7D)
  // make sure it matches ss_auto prgskills
  if (MODE == RBT_SKILL) {
    // set_slew(1);
    set_slew(0);
    WHEEL_MONITOR = START;
    DUMP_MONITOR = START;
    wheel_reset(-SIDE*360, 200, ang_side(-900));
    // initial movement - 4 stars 2 cube
    prg_mv1();
    // get the 2 cubes
    // wheel_reset(-360, 660, -900);
    wheel_reset(DRV.pos[0], Y_POS_FENCE, ang_side(-900));
    //prg_mv2();
    set_slew(0);
    WHEEL_MONITOR = STOP;
    DUMP_MONITOR = STOP;
  }

	while (true) {

    ///////////////////////////////////////////////////////
    // Controls for all modes
    ///////////////////////////////////////////////////////

		/*
			DRIVING CONTROL
		*/
		V = vexRT[Ch3];
		H = vexRT[Ch1];
		//V = vexRT[Ch2];
		//H = vexRT[Ch4];
		//Prevent against Small Motions

		if (abs(V) < MOTION_DRV_THRESHOLD) V = 0;
		if (abs(H) < MOTION_DRV_THRESHOLD) H = 0;
		move(V, H);
    // Shall we change to Truespeed???

		/*
			DUMPER CONTROL
      some Dumper controls only if transmission is set
		*/

		//Dumper control only if transmission is set
    // -- if Btn-5D is pushed, try to upper arm (otherwise will not move)
		if(vexRT[Btn6U] == 1){
			if(SensorValue(P_TRANS) == 0) DUMP_COMMAND = UP;
		}
    // -- if Btn-5D is pushed, try to lower arm (otherwise will not move)
		else if(vexRT[Btn6D] == 1){
			if(SensorValue(P_TRANS) == 0) DUMP_COMMAND = DOWN;
		}
		else if(vexRT[Btn5UXmtr2] == 1){
			DUMP_COMMAND = MANUAL_UP;
		}
		else if(vexRT[Btn5DXmtr2] == 1){
			DUMP_COMMAND = MANUAL_DOWN;
		}
		else if(DUMP_COMMAND != CARRY && DUMP_COMMAND != PRG && DUMP_COMMAND != HOLD && DUMP_COMMAND != WIGGLE){
			DUMP_COMMAND = STOP;
		}

		if((vexRT[Btn5D] == 1) && (SensorValue(P_TRANS) == 0) ) DUMP_COMMAND = HOLD;

 // -- if PR-Btn7L is pushed, do one dump and get out at 120 deg
    if ((get_pr_button(PR_Btn7L) == 1) && (SensorValue(P_TRANS) == 0)) {
			one_dump(1200, 1000, 750);
      DUMP_COMMAND = HOLD;
      reset_pr_button(PR_Btn7L);
		}
    // -- if PR-Btn8U is pushed, claw close and set to CARRY
    if ((get_pr_button(PR_Btn5U) == 1) && (SensorValue(P_TRANS) == 0)) {
      claw(CLOSE);
      wait1Msec(50);
      DUMP_COMMAND = CARRY;
      reset_pr_button(PR_Btn5U);
		}

		/*
			CLAW
		*/
    if (get_pr_button(PR_Btn8D) == 1) {
			claw(TOGGLE);
      reset_pr_button(PR_Btn8D);
		}

		/*
			LIFT CONTROL
		*/
    if (get_pr_button(PR_Btn8L) == 2) {
			//Toggle transmission -- has to hold on the button
			transmission(TOGGLE);
      reset_pr_button(PR_Btn8L);
		}

    if (MODE != TESTING && get_pr_button(PR_Btn8R) == 1) {
			//Put piston up
      SensorValue(P_LIFT) = 1;
      wait1Msec(500);
      SensorValue(P_LIFT) = 0;
      reset_pr_button(PR_Btn8R);
		}


    // add a special PB button for robot skills -- carry hight
    /*if ((MODE == RBT_SKILL) && (get_pr_button(PR_Btn7U) == 1) && (SensorValue(P_TRANS) == 0)) {
      DUMP_COMMAND = CARRY_HIGH;
      reset_pr_button(PR_Btn7U);
		}*/

    //Lift control only if transmission is set
		if(vexRT[Btn7U] == 1){
			if(SensorValue(P_TRANS) == 1) LIFT_COMMAND = UP;
		}
		else if(vexRT[Btn7D] == 1){
			if(SensorValue(P_TRANS) == 1) LIFT_COMMAND = DOWN;
		}
		else if(vexRT[Btn6UXmtr2] == 1){
			LIFT_COMMAND = MANUAL_UP;
		}
		else if(vexRT[Btn6DXmtr2] == 1){
			LIFT_COMMAND = MANUAL_DOWN;
		}
		else{
			LIFT_COMMAND = STOP;
		}

		if(vexRT[Btn8UXmtr2] == 1){
			SensorValue(P_LIFT) = 1;
		}
		if(vexRT[Btn8DXmtr2] == 1){
			SensorValue(P_LIFT) = 0;
		}

		///////////////////////////////////////////////////////
    // Controls for testing mode
    ///////////////////////////////////////////////////////

    if (MODE == TESTING) {
      // in testing model Btn8R test all 6 dump motors
      int waitT1 , waitT2 , vcmd;
    	// if(get_pr_button(PR_Btn7R) == 1){
    	if(get_pr_button(PR_Btn8U) == 1){
        waitT1 = 1000;
        waitT2 = 500;
        vcmd   = 127;
        motorReq[M_DRV_FL] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_FL] = 0; wait1Msec(waitT2);
        motorReq[M_DRV_BL] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_BL] = 0; wait1Msec(waitT2);
        motorReq[M_DRV_FR] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_FR] = 0; wait1Msec(waitT2);
        motorReq[M_DRV_BR] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_BR] = 0; wait1Msec(waitT2);
        reset_pr_button(PR_Btn8U);
        // reset_pr_button(PR_Btn7R);
      }
    	if(get_pr_button(PR_Btn8R) == 1){
        DUMP_COMMAND = PRG;   // make sure don't mess up DUMP_COMMAND
        waitT1 = 100;
        waitT2 = 500;
        vcmd   = 60;
        motorReq[M_DUMP_L1] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_L1] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_L2] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_L2] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_L3] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_L3] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_R1] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_R1] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_R2] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_R2] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_R3] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_R3] = 0; wait1Msec(waitT2);
        DUMP_COMMAND = STOP;
        reset_pr_button(PR_Btn8R);
      }
      if(get_pr_button(PR_Btn8L) == 1){
        // test auto_a()
        prg_skills();
        //LIFT_MONITOR = START;
				reset_pr_button(PR_Btn8L);
    	}

    	if(get_pr_button(PR_Btn8D) == 1){
        set_slew(1);
        // prg_skills();
        DUMP_MONITOR = STOP;
        WHEEL_MONITOR = STOP;

        /////// task 3 -- collect lift data; video and data needed to fine tune lift data
        // explore a better move for self alignment,


        /////// task 4 -- collect lift data and video
        // transmission(CLOSE);
        // wait1Msec(300);
        // if(DUMP_VAL < DUMP_RELEASE) dump_wiggle();
        // go_lift();

        /////// task 1 -- collect  data and video from mv 1 and 2
        // wheel_reset(-360, 200, -900); // test prg_mv1
        // prg_mv1();
        // prg_mv2();

        /////// task 2 -- collect  data and video from mv 1 and 2
        // wheel_reset(400, 660, -900);
        // prg_mv3();
        // prg_mv4();


        /////// task 5 -- fi have time and already concluded no other better options for alignment

        // wheel_reset(450, 660, -900);
        // prg_mv5();
        // wait1Msec(100);
        DUMP_MONITOR = STOP;
        WHEEL_MONITOR = STOP;
        set_slew(0);
        reset_pr_button(PR_Btn8D);
      }

    }

		lcd_message();
		wait1Msec(1);
		//wait1Msec(10);
	}
}
